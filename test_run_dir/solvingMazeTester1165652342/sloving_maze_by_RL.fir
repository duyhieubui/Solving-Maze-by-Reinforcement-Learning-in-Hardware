;buildInfoPackage: chisel3, version: 3.2.2, scalaVersion: 2.11.12, sbtVersion: 1.3.2
circuit sloving_maze_by_RL : 
  module Agent : 
    input clock : Clock
    input reset : Reset
    output io : {flip ROW : UInt<3>, flip COL : UInt<3>, flip new_state : UInt<6>, x : UInt<3>, y : UInt<3>, state : UInt<6>, episode : UInt<10>, done_learning : UInt<1>, flip load_new_state : UInt<1>, step : UInt<4>, iterate : UInt<1>, path_found : UInt<1>}
    
    reg ROW : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Blocks.scala 17:18]
    reg COL : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Blocks.scala 18:18]
    reg state : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[Blocks.scala 19:20]
    reg episode : UInt<10>, clock with : (reset => (reset, UInt<10>("h00"))) @[Blocks.scala 20:22]
    node start_again = eq(state, UInt<5>("h018")) @[Blocks.scala 21:24]
    reg step : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Blocks.scala 22:21]
    ROW <= io.ROW @[Blocks.scala 24:6]
    COL <= io.COL @[Blocks.scala 25:6]
    node t = eq(step, UInt<4>("h0f")) @[Blocks.scala 26:14]
    node iterate = or(start_again, t) @[Blocks.scala 28:26]
    io.iterate <= iterate @[Blocks.scala 29:13]
    node _T = eq(iterate, UInt<1>("h01")) @[Blocks.scala 30:15]
    when _T : @[Blocks.scala 30:25]
      state <= UInt<1>("h00") @[Blocks.scala 31:10]
      node _T_1 = add(episode, UInt<1>("h01")) @[Blocks.scala 32:21]
      node _T_2 = tail(_T_1, 1) @[Blocks.scala 32:21]
      episode <= _T_2 @[Blocks.scala 32:12]
      step <= UInt<1>("h00") @[Blocks.scala 33:11]
      skip @[Blocks.scala 30:25]
    else : @[Blocks.scala 34:4]
      when io.load_new_state : @[Blocks.scala 35:28]
        state <= io.new_state @[Blocks.scala 36:13]
        node _T_3 = add(step, UInt<1>("h01")) @[Blocks.scala 37:17]
        node _T_4 = tail(_T_3, 1) @[Blocks.scala 37:17]
        step <= _T_4 @[Blocks.scala 37:11]
        skip @[Blocks.scala 35:28]
      skip @[Blocks.scala 34:4]
    node _T_5 = eq(episode, UInt<9>("h012c")) @[Blocks.scala 41:15]
    when _T_5 : @[Blocks.scala 41:24]
      io.done_learning <= UInt<1>("h01") @[Blocks.scala 42:21]
      skip @[Blocks.scala 41:24]
    else : @[Blocks.scala 43:4]
      io.done_learning <= UInt<1>("h00") @[Blocks.scala 44:21]
      skip @[Blocks.scala 43:4]
    node _T_6 = eq(episode, UInt<9>("h012d")) @[Blocks.scala 48:15]
    when _T_6 : @[Blocks.scala 48:24]
      io.path_found <= UInt<1>("h01") @[Blocks.scala 49:18]
      skip @[Blocks.scala 48:24]
    else : @[Blocks.scala 50:4]
      io.path_found <= UInt<1>("h00") @[Blocks.scala 51:18]
      skip @[Blocks.scala 50:4]
    node _T_7 = rem(state, COL) @[Blocks.scala 55:14]
    io.x <= _T_7 @[Blocks.scala 55:7]
    node _T_8 = div(state, COL) @[Blocks.scala 56:14]
    io.y <= _T_8 @[Blocks.scala 56:7]
    io.state <= state @[Blocks.scala 57:11]
    io.episode <= episode @[Blocks.scala 58:13]
    io.step <= step @[Blocks.scala 59:10]
    
  module Action_FMS : 
    input clock : Clock
    input reset : Reset
    output io : {flip reset_Action_fms : UInt<1>, flip exploit : UInt<1>, flip validAction : UInt<1>, move_to_confirming_Reward : UInt<1>, keep_action : UInt<1>}
    
    reg action_FMS : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Action and ActionFMS.scala 13:27]
    io.move_to_confirming_Reward <= UInt<1>("h00") @[Action and ActionFMS.scala 14:32]
    io.keep_action <= UInt<1>("h01") @[Action and ActionFMS.scala 15:17]
    when io.reset_Action_fms : @[Action and ActionFMS.scala 16:29]
      action_FMS <= UInt<3>("h00") @[Action and ActionFMS.scala 17:16]
      skip @[Action and ActionFMS.scala 16:29]
    else : @[Action and ActionFMS.scala 18:5]
      node _T = eq(UInt<3>("h00"), action_FMS) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        io.keep_action <= UInt<1>("h00") @[Action and ActionFMS.scala 21:23]
        when io.exploit : @[Action and ActionFMS.scala 22:25]
          action_FMS <= UInt<3>("h01") @[Action and ActionFMS.scala 23:22]
          skip @[Action and ActionFMS.scala 22:25]
        else : @[Action and ActionFMS.scala 24:10]
          action_FMS <= UInt<3>("h02") @[Action and ActionFMS.scala 25:22]
          skip @[Action and ActionFMS.scala 24:10]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<3>("h01"), action_FMS) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          action_FMS <= UInt<3>("h03") @[Action and ActionFMS.scala 29:20]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_2 = eq(UInt<3>("h02"), action_FMS) @[Conditional.scala 37:30]
          when _T_2 : @[Conditional.scala 39:67]
            action_FMS <= UInt<3>("h03") @[Action and ActionFMS.scala 32:20]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_3 = eq(UInt<3>("h03"), action_FMS) @[Conditional.scala 37:30]
            when _T_3 : @[Conditional.scala 39:67]
              action_FMS <= UInt<3>("h04") @[Action and ActionFMS.scala 35:20]
              skip @[Conditional.scala 39:67]
            else : @[Conditional.scala 39:67]
              node _T_4 = eq(UInt<3>("h04"), action_FMS) @[Conditional.scala 37:30]
              when _T_4 : @[Conditional.scala 39:67]
                when io.validAction : @[Action and ActionFMS.scala 38:29]
                  io.move_to_confirming_Reward <= UInt<1>("h01") @[Action and ActionFMS.scala 39:40]
                  action_FMS <= UInt<3>("h04") @[Action and ActionFMS.scala 40:22]
                  skip @[Action and ActionFMS.scala 38:29]
                else : @[Action and ActionFMS.scala 41:10]
                  action_FMS <= UInt<3>("h00") @[Action and ActionFMS.scala 42:22]
                  skip @[Action and ActionFMS.scala 41:10]
                skip @[Conditional.scala 39:67]
      skip @[Action and ActionFMS.scala 18:5]
    
  module Action : 
    input clock : Clock
    input reset : Reset
    output io : {flip x : UInt<3>, flip y : UInt<3>, flip rand2 : UInt<10>, new_state : UInt<6>, act : UInt<2>, flip action_at_Qmax : UInt<2>, flip exploit : UInt<1>, validAction : UInt<1>, flip keep_action : UInt<1>}
    
    reg act : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Action and ActionFMS.scala 60:20]
    reg x_new : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Action and ActionFMS.scala 61:22]
    reg y_new : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Action and ActionFMS.scala 62:22]
    reg new_state : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[Action and ActionFMS.scala 63:24]
    reg action_at_Qmax : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Action and ActionFMS.scala 64:29]
    action_at_Qmax <= io.action_at_Qmax @[Action and ActionFMS.scala 66:17]
    node _T = eq(io.keep_action, UInt<1>("h00")) @[Action and ActionFMS.scala 67:22]
    when _T : @[Action and ActionFMS.scala 67:33]
      when io.exploit : @[Action and ActionFMS.scala 68:21]
        act <= action_at_Qmax @[Action and ActionFMS.scala 69:11]
        skip @[Action and ActionFMS.scala 68:21]
      else : @[Action and ActionFMS.scala 70:6]
        node _T_1 = leq(io.rand2, UInt<14>("h03fff")) @[Action and ActionFMS.scala 71:21]
        when _T_1 : @[Action and ActionFMS.scala 71:32]
          act <= UInt<1>("h00") @[Action and ActionFMS.scala 72:13]
          skip @[Action and ActionFMS.scala 71:32]
        else : @[Action and ActionFMS.scala 73:76]
          node _T_2 = lt(UInt<14>("h03fff"), io.rand2) @[Action and ActionFMS.scala 73:27]
          node _T_3 = leq(io.rand2, UInt<15>("h07fff")) @[Action and ActionFMS.scala 73:52]
          node _T_4 = eq(_T_3, UInt<1>("h01")) @[Action and ActionFMS.scala 73:64]
          node _T_5 = and(_T_2, _T_4) @[Action and ActionFMS.scala 73:39]
          when _T_5 : @[Action and ActionFMS.scala 73:76]
            act <= UInt<1>("h01") @[Action and ActionFMS.scala 74:13]
            skip @[Action and ActionFMS.scala 73:76]
          else : @[Action and ActionFMS.scala 75:76]
            node _T_6 = lt(UInt<15>("h07fff"), io.rand2) @[Action and ActionFMS.scala 75:27]
            node _T_7 = leq(io.rand2, UInt<16>("h0bffe")) @[Action and ActionFMS.scala 75:52]
            node _T_8 = eq(_T_7, UInt<1>("h01")) @[Action and ActionFMS.scala 75:64]
            node _T_9 = and(_T_6, _T_8) @[Action and ActionFMS.scala 75:39]
            when _T_9 : @[Action and ActionFMS.scala 75:76]
              act <= UInt<2>("h02") @[Action and ActionFMS.scala 76:13]
              skip @[Action and ActionFMS.scala 75:76]
            else : @[Action and ActionFMS.scala 77:9]
              act <= UInt<2>("h03") @[Action and ActionFMS.scala 78:13]
              skip @[Action and ActionFMS.scala 77:9]
        skip @[Action and ActionFMS.scala 70:6]
      skip @[Action and ActionFMS.scala 67:33]
    node _T_10 = eq(act, UInt<1>("h00")) @[Action and ActionFMS.scala 82:12]
    when _T_10 : @[Action and ActionFMS.scala 82:21]
      node _T_11 = add(io.y, UInt<1>("h01")) @[Action and ActionFMS.scala 83:19]
      node _T_12 = tail(_T_11, 1) @[Action and ActionFMS.scala 83:19]
      y_new <= _T_12 @[Action and ActionFMS.scala 83:11]
      x_new <= io.x @[Action and ActionFMS.scala 84:11]
      skip @[Action and ActionFMS.scala 82:21]
    else : @[Action and ActionFMS.scala 85:27]
      node _T_13 = eq(act, UInt<1>("h01")) @[Action and ActionFMS.scala 85:18]
      when _T_13 : @[Action and ActionFMS.scala 85:27]
        node _T_14 = sub(io.x, UInt<1>("h01")) @[Action and ActionFMS.scala 86:19]
        node _T_15 = tail(_T_14, 1) @[Action and ActionFMS.scala 86:19]
        x_new <= _T_15 @[Action and ActionFMS.scala 86:11]
        y_new <= io.y @[Action and ActionFMS.scala 87:11]
        skip @[Action and ActionFMS.scala 85:27]
      else : @[Action and ActionFMS.scala 88:27]
        node _T_16 = eq(act, UInt<2>("h02")) @[Action and ActionFMS.scala 88:18]
        when _T_16 : @[Action and ActionFMS.scala 88:27]
          node _T_17 = sub(io.y, UInt<1>("h01")) @[Action and ActionFMS.scala 89:19]
          node _T_18 = tail(_T_17, 1) @[Action and ActionFMS.scala 89:19]
          y_new <= _T_18 @[Action and ActionFMS.scala 89:11]
          x_new <= io.x @[Action and ActionFMS.scala 90:11]
          skip @[Action and ActionFMS.scala 88:27]
        else : @[Action and ActionFMS.scala 91:5]
          node _T_19 = add(io.x, UInt<1>("h01")) @[Action and ActionFMS.scala 92:19]
          node _T_20 = tail(_T_19, 1) @[Action and ActionFMS.scala 92:19]
          x_new <= _T_20 @[Action and ActionFMS.scala 92:11]
          y_new <= io.y @[Action and ActionFMS.scala 93:11]
          skip @[Action and ActionFMS.scala 91:5]
    node _T_21 = eq(x_new, UInt<3>("h07")) @[Action and ActionFMS.scala 95:14]
    node _T_22 = eq(x_new, UInt<3>("h05")) @[Action and ActionFMS.scala 95:31]
    node _T_23 = or(_T_21, _T_22) @[Action and ActionFMS.scala 95:22]
    node _T_24 = eq(y_new, UInt<3>("h07")) @[Action and ActionFMS.scala 95:48]
    node _T_25 = or(_T_23, _T_24) @[Action and ActionFMS.scala 95:39]
    node _T_26 = eq(y_new, UInt<3>("h05")) @[Action and ActionFMS.scala 95:65]
    node _T_27 = or(_T_25, _T_26) @[Action and ActionFMS.scala 95:56]
    when _T_27 : @[Action and ActionFMS.scala 95:73]
      io.validAction <= UInt<1>("h00") @[Action and ActionFMS.scala 96:19]
      skip @[Action and ActionFMS.scala 95:73]
    else : @[Action and ActionFMS.scala 97:4]
      node _T_28 = mul(UInt<3>("h05"), y_new) @[Action and ActionFMS.scala 98:25]
      node _T_29 = add(x_new, _T_28) @[Action and ActionFMS.scala 98:21]
      node _T_30 = tail(_T_29, 1) @[Action and ActionFMS.scala 98:21]
      new_state <= _T_30 @[Action and ActionFMS.scala 98:14]
      io.validAction <= UInt<1>("h01") @[Action and ActionFMS.scala 99:19]
      skip @[Action and ActionFMS.scala 97:4]
    io.act <= act @[Action and ActionFMS.scala 101:9]
    io.new_state <= new_state @[Action and ActionFMS.scala 102:15]
    
  module MaxPeriodFibonacciLFSR : 
    input clock : Clock
    input reset : Reset
    output io : {flip seed : {valid : UInt<1>, bits : UInt<1>[16]}, flip increment : UInt<1>, out : UInt<1>[16]}
    
    wire _T : UInt<1>[16] @[PRNG.scala 38:28]
    _T[0] <= UInt<1>("h01") @[PRNG.scala 38:28]
    _T[1] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[2] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[3] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[4] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[5] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[6] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[7] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[8] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[9] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[10] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[11] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[12] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[13] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[14] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[15] <= UInt<1>("h00") @[PRNG.scala 38:28]
    reg state : UInt<1>[16], clock with : (reset => (reset, _T)) @[PRNG.scala 47:50]
    when io.increment : @[PRNG.scala 61:23]
      node _T_1 = xor(state[15], state[13]) @[LFSR.scala 15:41]
      node _T_2 = xor(_T_1, state[12]) @[LFSR.scala 15:41]
      node _T_3 = xor(_T_2, state[10]) @[LFSR.scala 15:41]
      state[0] <= _T_3 @[PRNG.scala 62:11]
      state[1] <= state[0] @[PRNG.scala 62:11]
      state[2] <= state[1] @[PRNG.scala 62:11]
      state[3] <= state[2] @[PRNG.scala 62:11]
      state[4] <= state[3] @[PRNG.scala 62:11]
      state[5] <= state[4] @[PRNG.scala 62:11]
      state[6] <= state[5] @[PRNG.scala 62:11]
      state[7] <= state[6] @[PRNG.scala 62:11]
      state[8] <= state[7] @[PRNG.scala 62:11]
      state[9] <= state[8] @[PRNG.scala 62:11]
      state[10] <= state[9] @[PRNG.scala 62:11]
      state[11] <= state[10] @[PRNG.scala 62:11]
      state[12] <= state[11] @[PRNG.scala 62:11]
      state[13] <= state[12] @[PRNG.scala 62:11]
      state[14] <= state[13] @[PRNG.scala 62:11]
      state[15] <= state[14] @[PRNG.scala 62:11]
      skip @[PRNG.scala 61:23]
    when io.seed.valid : @[PRNG.scala 65:25]
      state[0] <= io.seed.bits[0] @[PRNG.scala 66:11]
      state[1] <= io.seed.bits[1] @[PRNG.scala 66:11]
      state[2] <= io.seed.bits[2] @[PRNG.scala 66:11]
      state[3] <= io.seed.bits[3] @[PRNG.scala 66:11]
      state[4] <= io.seed.bits[4] @[PRNG.scala 66:11]
      state[5] <= io.seed.bits[5] @[PRNG.scala 66:11]
      state[6] <= io.seed.bits[6] @[PRNG.scala 66:11]
      state[7] <= io.seed.bits[7] @[PRNG.scala 66:11]
      state[8] <= io.seed.bits[8] @[PRNG.scala 66:11]
      state[9] <= io.seed.bits[9] @[PRNG.scala 66:11]
      state[10] <= io.seed.bits[10] @[PRNG.scala 66:11]
      state[11] <= io.seed.bits[11] @[PRNG.scala 66:11]
      state[12] <= io.seed.bits[12] @[PRNG.scala 66:11]
      state[13] <= io.seed.bits[13] @[PRNG.scala 66:11]
      state[14] <= io.seed.bits[14] @[PRNG.scala 66:11]
      state[15] <= io.seed.bits[15] @[PRNG.scala 66:11]
      skip @[PRNG.scala 65:25]
    io.out[0] <= state[0] @[PRNG.scala 69:10]
    io.out[1] <= state[1] @[PRNG.scala 69:10]
    io.out[2] <= state[2] @[PRNG.scala 69:10]
    io.out[3] <= state[3] @[PRNG.scala 69:10]
    io.out[4] <= state[4] @[PRNG.scala 69:10]
    io.out[5] <= state[5] @[PRNG.scala 69:10]
    io.out[6] <= state[6] @[PRNG.scala 69:10]
    io.out[7] <= state[7] @[PRNG.scala 69:10]
    io.out[8] <= state[8] @[PRNG.scala 69:10]
    io.out[9] <= state[9] @[PRNG.scala 69:10]
    io.out[10] <= state[10] @[PRNG.scala 69:10]
    io.out[11] <= state[11] @[PRNG.scala 69:10]
    io.out[12] <= state[12] @[PRNG.scala 69:10]
    io.out[13] <= state[13] @[PRNG.scala 69:10]
    io.out[14] <= state[14] @[PRNG.scala 69:10]
    io.out[15] <= state[15] @[PRNG.scala 69:10]
    
  module MaxPeriodFibonacciLFSR_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip seed : {valid : UInt<1>, bits : UInt<1>[16]}, flip increment : UInt<1>, out : UInt<1>[16]}
    
    wire _T : UInt<1>[16] @[PRNG.scala 38:28]
    _T[0] <= UInt<1>("h01") @[PRNG.scala 38:28]
    _T[1] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[2] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[3] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[4] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[5] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[6] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[7] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[8] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[9] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[10] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[11] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[12] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[13] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[14] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[15] <= UInt<1>("h00") @[PRNG.scala 38:28]
    reg state : UInt<1>[16], clock with : (reset => (reset, _T)) @[PRNG.scala 47:50]
    when io.increment : @[PRNG.scala 61:23]
      node _T_1 = xor(state[15], state[13]) @[LFSR.scala 15:41]
      node _T_2 = xor(_T_1, state[12]) @[LFSR.scala 15:41]
      node _T_3 = xor(_T_2, state[10]) @[LFSR.scala 15:41]
      state[0] <= _T_3 @[PRNG.scala 62:11]
      state[1] <= state[0] @[PRNG.scala 62:11]
      state[2] <= state[1] @[PRNG.scala 62:11]
      state[3] <= state[2] @[PRNG.scala 62:11]
      state[4] <= state[3] @[PRNG.scala 62:11]
      state[5] <= state[4] @[PRNG.scala 62:11]
      state[6] <= state[5] @[PRNG.scala 62:11]
      state[7] <= state[6] @[PRNG.scala 62:11]
      state[8] <= state[7] @[PRNG.scala 62:11]
      state[9] <= state[8] @[PRNG.scala 62:11]
      state[10] <= state[9] @[PRNG.scala 62:11]
      state[11] <= state[10] @[PRNG.scala 62:11]
      state[12] <= state[11] @[PRNG.scala 62:11]
      state[13] <= state[12] @[PRNG.scala 62:11]
      state[14] <= state[13] @[PRNG.scala 62:11]
      state[15] <= state[14] @[PRNG.scala 62:11]
      skip @[PRNG.scala 61:23]
    when io.seed.valid : @[PRNG.scala 65:25]
      state[0] <= io.seed.bits[0] @[PRNG.scala 66:11]
      state[1] <= io.seed.bits[1] @[PRNG.scala 66:11]
      state[2] <= io.seed.bits[2] @[PRNG.scala 66:11]
      state[3] <= io.seed.bits[3] @[PRNG.scala 66:11]
      state[4] <= io.seed.bits[4] @[PRNG.scala 66:11]
      state[5] <= io.seed.bits[5] @[PRNG.scala 66:11]
      state[6] <= io.seed.bits[6] @[PRNG.scala 66:11]
      state[7] <= io.seed.bits[7] @[PRNG.scala 66:11]
      state[8] <= io.seed.bits[8] @[PRNG.scala 66:11]
      state[9] <= io.seed.bits[9] @[PRNG.scala 66:11]
      state[10] <= io.seed.bits[10] @[PRNG.scala 66:11]
      state[11] <= io.seed.bits[11] @[PRNG.scala 66:11]
      state[12] <= io.seed.bits[12] @[PRNG.scala 66:11]
      state[13] <= io.seed.bits[13] @[PRNG.scala 66:11]
      state[14] <= io.seed.bits[14] @[PRNG.scala 66:11]
      state[15] <= io.seed.bits[15] @[PRNG.scala 66:11]
      skip @[PRNG.scala 65:25]
    io.out[0] <= state[0] @[PRNG.scala 69:10]
    io.out[1] <= state[1] @[PRNG.scala 69:10]
    io.out[2] <= state[2] @[PRNG.scala 69:10]
    io.out[3] <= state[3] @[PRNG.scala 69:10]
    io.out[4] <= state[4] @[PRNG.scala 69:10]
    io.out[5] <= state[5] @[PRNG.scala 69:10]
    io.out[6] <= state[6] @[PRNG.scala 69:10]
    io.out[7] <= state[7] @[PRNG.scala 69:10]
    io.out[8] <= state[8] @[PRNG.scala 69:10]
    io.out[9] <= state[9] @[PRNG.scala 69:10]
    io.out[10] <= state[10] @[PRNG.scala 69:10]
    io.out[11] <= state[11] @[PRNG.scala 69:10]
    io.out[12] <= state[12] @[PRNG.scala 69:10]
    io.out[13] <= state[13] @[PRNG.scala 69:10]
    io.out[14] <= state[14] @[PRNG.scala 69:10]
    io.out[15] <= state[15] @[PRNG.scala 69:10]
    
  module takingAction : 
    input clock : Clock
    input reset : Reset
    output io : {flip x : UInt<3>, flip y : UInt<3>, flip episode : UInt<10>, new_state : UInt<6>, flip action_at_Qmax : UInt<2>, act : UInt<2>, flip reset_Action_fms : UInt<1>, move_to_confirming_Reward : UInt<1>, flip get_path : UInt<1>}
    
    inst action_fms of Action_FMS @[taking_Action.scala 16:24]
    action_fms.clock <= clock
    action_fms.reset <= reset
    inst action of Action @[taking_Action.scala 17:20]
    action.clock <= clock
    action.reset <= reset
    reg epsilon : UInt<16>, clock with : (reset => (reset, UInt<16>("h00"))) @[taking_Action.scala 18:24]
    node _T = mul(io.episode, UInt<8>("h0d9")) @[taking_Action.scala 20:30]
    node _T_1 = sub(UInt<16>("h0ffff"), _T) @[taking_Action.scala 20:19]
    node _T_2 = tail(_T_1, 1) @[taking_Action.scala 20:19]
    epsilon <= _T_2 @[taking_Action.scala 20:10]
    inst MaxPeriodFibonacciLFSR of MaxPeriodFibonacciLFSR @[PRNG.scala 82:22]
    MaxPeriodFibonacciLFSR.clock <= clock
    MaxPeriodFibonacciLFSR.reset <= reset
    MaxPeriodFibonacciLFSR.io.seed.valid <= UInt<1>("h00") @[PRNG.scala 83:24]
    MaxPeriodFibonacciLFSR.io.seed.bits[0] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[1] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[2] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[3] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[4] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[5] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[6] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[7] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[8] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[9] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[10] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[11] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[12] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[13] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[14] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[15] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.increment <= UInt<1>("h01") @[PRNG.scala 85:23]
    node _T_3 = cat(MaxPeriodFibonacciLFSR.io.out[1], MaxPeriodFibonacciLFSR.io.out[0]) @[PRNG.scala 86:17]
    node _T_4 = cat(MaxPeriodFibonacciLFSR.io.out[3], MaxPeriodFibonacciLFSR.io.out[2]) @[PRNG.scala 86:17]
    node _T_5 = cat(_T_4, _T_3) @[PRNG.scala 86:17]
    node _T_6 = cat(MaxPeriodFibonacciLFSR.io.out[5], MaxPeriodFibonacciLFSR.io.out[4]) @[PRNG.scala 86:17]
    node _T_7 = cat(MaxPeriodFibonacciLFSR.io.out[7], MaxPeriodFibonacciLFSR.io.out[6]) @[PRNG.scala 86:17]
    node _T_8 = cat(_T_7, _T_6) @[PRNG.scala 86:17]
    node _T_9 = cat(_T_8, _T_5) @[PRNG.scala 86:17]
    node _T_10 = cat(MaxPeriodFibonacciLFSR.io.out[9], MaxPeriodFibonacciLFSR.io.out[8]) @[PRNG.scala 86:17]
    node _T_11 = cat(MaxPeriodFibonacciLFSR.io.out[11], MaxPeriodFibonacciLFSR.io.out[10]) @[PRNG.scala 86:17]
    node _T_12 = cat(_T_11, _T_10) @[PRNG.scala 86:17]
    node _T_13 = cat(MaxPeriodFibonacciLFSR.io.out[13], MaxPeriodFibonacciLFSR.io.out[12]) @[PRNG.scala 86:17]
    node _T_14 = cat(MaxPeriodFibonacciLFSR.io.out[15], MaxPeriodFibonacciLFSR.io.out[14]) @[PRNG.scala 86:17]
    node _T_15 = cat(_T_14, _T_13) @[PRNG.scala 86:17]
    node _T_16 = cat(_T_15, _T_12) @[PRNG.scala 86:17]
    node _T_17 = cat(_T_16, _T_9) @[PRNG.scala 86:17]
    node exploit1 = lt(epsilon, _T_17) @[taking_Action.scala 21:24]
    node exploit = or(exploit1, io.get_path) @[taking_Action.scala 22:23]
    action_fms.io.reset_Action_fms <= io.reset_Action_fms @[taking_Action.scala 25:33]
    action_fms.io.exploit <= exploit @[taking_Action.scala 26:24]
    action_fms.io.validAction <= action.io.validAction @[taking_Action.scala 27:28]
    action.io.keep_action <= action_fms.io.keep_action @[taking_Action.scala 28:28]
    action.io.exploit <= exploit @[taking_Action.scala 30:20]
    inst MaxPeriodFibonacciLFSR_1 of MaxPeriodFibonacciLFSR_1 @[PRNG.scala 82:22]
    MaxPeriodFibonacciLFSR_1.clock <= clock
    MaxPeriodFibonacciLFSR_1.reset <= reset
    MaxPeriodFibonacciLFSR_1.io.seed.valid <= UInt<1>("h00") @[PRNG.scala 83:24]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[0] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[1] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[2] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[3] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[4] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[5] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[6] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[7] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[8] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[9] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[10] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[11] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[12] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[13] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[14] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.seed.bits[15] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR_1.io.increment <= UInt<1>("h01") @[PRNG.scala 85:23]
    node _T_18 = cat(MaxPeriodFibonacciLFSR_1.io.out[1], MaxPeriodFibonacciLFSR_1.io.out[0]) @[PRNG.scala 86:17]
    node _T_19 = cat(MaxPeriodFibonacciLFSR_1.io.out[3], MaxPeriodFibonacciLFSR_1.io.out[2]) @[PRNG.scala 86:17]
    node _T_20 = cat(_T_19, _T_18) @[PRNG.scala 86:17]
    node _T_21 = cat(MaxPeriodFibonacciLFSR_1.io.out[5], MaxPeriodFibonacciLFSR_1.io.out[4]) @[PRNG.scala 86:17]
    node _T_22 = cat(MaxPeriodFibonacciLFSR_1.io.out[7], MaxPeriodFibonacciLFSR_1.io.out[6]) @[PRNG.scala 86:17]
    node _T_23 = cat(_T_22, _T_21) @[PRNG.scala 86:17]
    node _T_24 = cat(_T_23, _T_20) @[PRNG.scala 86:17]
    node _T_25 = cat(MaxPeriodFibonacciLFSR_1.io.out[9], MaxPeriodFibonacciLFSR_1.io.out[8]) @[PRNG.scala 86:17]
    node _T_26 = cat(MaxPeriodFibonacciLFSR_1.io.out[11], MaxPeriodFibonacciLFSR_1.io.out[10]) @[PRNG.scala 86:17]
    node _T_27 = cat(_T_26, _T_25) @[PRNG.scala 86:17]
    node _T_28 = cat(MaxPeriodFibonacciLFSR_1.io.out[13], MaxPeriodFibonacciLFSR_1.io.out[12]) @[PRNG.scala 86:17]
    node _T_29 = cat(MaxPeriodFibonacciLFSR_1.io.out[15], MaxPeriodFibonacciLFSR_1.io.out[14]) @[PRNG.scala 86:17]
    node _T_30 = cat(_T_29, _T_28) @[PRNG.scala 86:17]
    node _T_31 = cat(_T_30, _T_27) @[PRNG.scala 86:17]
    node _T_32 = cat(_T_31, _T_24) @[PRNG.scala 86:17]
    action.io.rand2 <= _T_32 @[taking_Action.scala 31:18]
    action.io.x <= io.x @[taking_Action.scala 33:14]
    action.io.y <= io.y @[taking_Action.scala 34:14]
    action.io.action_at_Qmax <= io.action_at_Qmax @[taking_Action.scala 35:27]
    io.act <= action.io.act @[taking_Action.scala 37:9]
    io.new_state <= action.io.new_state @[taking_Action.scala 38:15]
    io.move_to_confirming_Reward <= action_fms.io.move_to_confirming_Reward @[taking_Action.scala 39:31]
    
  module Q_function : 
    input clock : Clock
    input reset : Reset
    output io : {flip Q_s_a : SInt<16>, flip Q_prime_max : SInt<16>, Q_updated : SInt<16>, flip cal : UInt<1>, flip reward : SInt<9>, wrEna : UInt<1>}
    
    reg Q_s_a : SInt<16>, clock with : (reset => (reset, asSInt(UInt<16>("h00")))) @[Q_function.scala 15:20]
    reg reward : SInt<9>, clock with : (reset => (reset, asSInt(UInt<9>("h00")))) @[Q_function.scala 16:21]
    Q_s_a <= io.Q_s_a @[Q_function.scala 17:8]
    reward <= io.reward @[Q_function.scala 18:9]
    when io.cal : @[Q_function.scala 19:15]
      node _T = mul(reward, asSInt(UInt<9>("h080"))) @[Q_function.scala 20:33]
      node _T_1 = add(Q_s_a, _T) @[Q_function.scala 20:26]
      node _T_2 = tail(_T_1, 1) @[Q_function.scala 20:26]
      node _T_3 = asSInt(_T_2) @[Q_function.scala 20:26]
      node _T_4 = div(_T_3, asSInt(UInt<3>("h02"))) @[Q_function.scala 20:40]
      node _T_5 = mul(io.Q_prime_max, asSInt(UInt<3>("h02"))) @[Q_function.scala 20:61]
      node _T_6 = div(_T_5, asSInt(UInt<4>("h05"))) @[Q_function.scala 20:65]
      node _T_7 = add(_T_4, _T_6) @[Q_function.scala 20:45]
      node _T_8 = tail(_T_7, 1) @[Q_function.scala 20:45]
      node _T_9 = asSInt(_T_8) @[Q_function.scala 20:45]
      io.Q_updated <= _T_9 @[Q_function.scala 20:18]
      io.wrEna <= UInt<1>("h01") @[Q_function.scala 21:13]
      skip @[Q_function.scala 19:15]
    else : @[Q_function.scala 22:4]
      io.Q_updated <= asSInt(UInt<1>("h00")) @[Q_function.scala 23:17]
      io.wrEna <= UInt<1>("h00") @[Q_function.scala 24:13]
      skip @[Q_function.scala 22:4]
    
  module Max4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip ins0 : SInt<16>, flip ins1 : SInt<16>, flip ins2 : SInt<16>, flip ins3 : SInt<16>, Q_max : SInt<16>}
    
    wire ins : SInt<16>[4] @[Q_table.scala 82:15]
    ins[0] <= io.ins0 @[Q_table.scala 83:9]
    ins[1] <= io.ins1 @[Q_table.scala 84:9]
    ins[2] <= io.ins2 @[Q_table.scala 85:9]
    ins[3] <= io.ins3 @[Q_table.scala 86:9]
    node _T = gt(ins[0], ins[1]) @[Q_table.scala 81:46]
    node _T_1 = mux(_T, ins[0], ins[1]) @[Q_table.scala 81:43]
    node _T_2 = gt(_T_1, ins[2]) @[Q_table.scala 81:46]
    node _T_3 = mux(_T_2, _T_1, ins[2]) @[Q_table.scala 81:43]
    node _T_4 = gt(_T_3, ins[3]) @[Q_table.scala 81:46]
    node _T_5 = mux(_T_4, _T_3, ins[3]) @[Q_table.scala 81:43]
    io.Q_max <= _T_5 @[Q_table.scala 87:11]
    
  module Action_at_Qmax : 
    input clock : Clock
    input reset : Reset
    output io : {flip ins0 : SInt<16>, flip ins1 : SInt<16>, flip ins2 : SInt<16>, flip ins3 : SInt<16>, action_at_Qmax : UInt<2>, flip Q_max_at_state_s : SInt<16>}
    
    wire ins : SInt<16>[4] @[Q_table.scala 98:15]
    ins[0] <= io.ins0 @[Q_table.scala 99:9]
    ins[1] <= io.ins1 @[Q_table.scala 100:9]
    ins[2] <= io.ins2 @[Q_table.scala 101:9]
    ins[3] <= io.ins3 @[Q_table.scala 102:9]
    node _T = eq(ins[0], io.Q_max_at_state_s) @[Q_table.scala 103:42]
    node _T_1 = eq(ins[1], io.Q_max_at_state_s) @[Q_table.scala 103:42]
    node _T_2 = eq(ins[2], io.Q_max_at_state_s) @[Q_table.scala 103:42]
    node _T_3 = eq(ins[3], io.Q_max_at_state_s) @[Q_table.scala 103:42]
    node _T_4 = mux(_T_2, UInt<2>("h02"), UInt<2>("h03")) @[Q_table.scala 103:36]
    node _T_5 = mux(_T_1, UInt<1>("h01"), _T_4) @[Q_table.scala 103:36]
    node _T_6 = mux(_T, UInt<1>("h00"), _T_5) @[Q_table.scala 103:36]
    io.action_at_Qmax <= _T_6 @[Q_table.scala 103:20]
    
  module Qtable : 
    input clock : Clock
    input reset : Reset
    output io : {flip state : UInt<6>, flip new_state : UInt<6>, flip act : UInt<2>, flip wrEna : UInt<1>, flip Q_updated : SInt<16>, Q_s_a : SInt<16>, Q_prime_max : SInt<16>, action_at_Qmax : UInt<2>, flip get_Q_prime_max : UInt<1>, flip write_data_into_a_txtfile : UInt<1>, flip act_read : UInt<2>, flip state_read : UInt<6>}
    
    inst max4 of Max4 @[Q_table.scala 18:18]
    max4.clock <= clock
    max4.reset <= reset
    inst index_of_Q_max of Action_at_Qmax @[Q_table.scala 19:28]
    index_of_Q_max.clock <= clock
    index_of_Q_max.reset <= reset
    smem Q_s_a0 : SInt<16>[25] @[Q_table.scala 21:25]
    smem Q_s_a1 : SInt<16>[25] @[Q_table.scala 22:25]
    smem Q_s_a2 : SInt<16>[25] @[Q_table.scala 23:25]
    smem Q_s_a3 : SInt<16>[25] @[Q_table.scala 24:25]
    reg state_addr : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[Q_table.scala 25:25]
    state_addr <= io.state @[Q_table.scala 26:13]
    node act = mux(io.write_data_into_a_txtfile, io.act_read, io.act) @[Q_table.scala 27:14]
    node stateRead = mux(io.write_data_into_a_txtfile, io.state_read, io.state) @[Q_table.scala 28:20]
    io.Q_s_a <= asSInt(UInt<1>("h00")) @[Q_table.scala 29:11]
    node _T = eq(act, UInt<1>("h00")) @[Q_table.scala 30:11]
    when _T : @[Q_table.scala 30:18]
      when io.wrEna : @[Q_table.scala 31:20]
        node _T_1 = bits(state_addr, 4, 0)
        write mport _T_2 = Q_s_a0[_T_1], clock
        _T_2 <= io.Q_updated
        skip @[Q_table.scala 31:20]
      else : @[Q_table.scala 33:6]
        node _T_3 = bits(stateRead, 4, 0) @[Q_table.scala 34:28]
        read mport _T_4 = Q_s_a0[_T_3], clock @[Q_table.scala 34:28]
        io.Q_s_a <= _T_4 @[Q_table.scala 34:15]
        skip @[Q_table.scala 33:6]
      skip @[Q_table.scala 30:18]
    else : @[Q_table.scala 36:24]
      node _T_5 = eq(act, UInt<1>("h01")) @[Q_table.scala 36:17]
      when _T_5 : @[Q_table.scala 36:24]
        when io.wrEna : @[Q_table.scala 37:20]
          node _T_6 = bits(state_addr, 4, 0)
          write mport _T_7 = Q_s_a1[_T_6], clock
          _T_7 <= io.Q_updated
          skip @[Q_table.scala 37:20]
        else : @[Q_table.scala 39:6]
          node _T_8 = bits(stateRead, 4, 0) @[Q_table.scala 40:28]
          read mport _T_9 = Q_s_a1[_T_8], clock @[Q_table.scala 40:28]
          io.Q_s_a <= _T_9 @[Q_table.scala 40:15]
          skip @[Q_table.scala 39:6]
        skip @[Q_table.scala 36:24]
      else : @[Q_table.scala 42:24]
        node _T_10 = eq(act, UInt<2>("h02")) @[Q_table.scala 42:17]
        when _T_10 : @[Q_table.scala 42:24]
          when io.wrEna : @[Q_table.scala 43:20]
            node _T_11 = bits(state_addr, 4, 0)
            write mport _T_12 = Q_s_a2[_T_11], clock
            _T_12 <= io.Q_updated
            skip @[Q_table.scala 43:20]
          else : @[Q_table.scala 45:6]
            node _T_13 = bits(stateRead, 4, 0) @[Q_table.scala 46:28]
            read mport _T_14 = Q_s_a2[_T_13], clock @[Q_table.scala 46:28]
            io.Q_s_a <= _T_14 @[Q_table.scala 46:15]
            skip @[Q_table.scala 45:6]
          skip @[Q_table.scala 42:24]
        else : @[Q_table.scala 48:4]
          when io.wrEna : @[Q_table.scala 49:19]
            node _T_15 = bits(state_addr, 4, 0)
            write mport _T_16 = Q_s_a3[_T_15], clock
            _T_16 <= io.Q_updated
            skip @[Q_table.scala 49:19]
          else : @[Q_table.scala 51:6]
            node _T_17 = bits(stateRead, 4, 0) @[Q_table.scala 52:28]
            read mport _T_18 = Q_s_a3[_T_17], clock @[Q_table.scala 52:28]
            io.Q_s_a <= _T_18 @[Q_table.scala 52:15]
            skip @[Q_table.scala 51:6]
          skip @[Q_table.scala 48:4]
    node new_state_or_state = mux(io.get_Q_prime_max, io.new_state, io.state) @[Q_table.scala 59:29]
    node _T_19 = bits(new_state_or_state, 4, 0) @[Q_table.scala 60:28]
    read mport _T_20 = Q_s_a0[_T_19], clock @[Q_table.scala 60:28]
    max4.io.ins0 <= _T_20 @[Q_table.scala 60:15]
    node _T_21 = bits(new_state_or_state, 4, 0) @[Q_table.scala 61:28]
    read mport _T_22 = Q_s_a1[_T_21], clock @[Q_table.scala 61:28]
    max4.io.ins1 <= _T_22 @[Q_table.scala 61:15]
    node _T_23 = bits(new_state_or_state, 4, 0) @[Q_table.scala 62:28]
    read mport _T_24 = Q_s_a1[_T_23], clock @[Q_table.scala 62:28]
    max4.io.ins2 <= _T_24 @[Q_table.scala 62:15]
    node _T_25 = bits(new_state_or_state, 4, 0) @[Q_table.scala 63:28]
    read mport _T_26 = Q_s_a3[_T_25], clock @[Q_table.scala 63:28]
    max4.io.ins3 <= _T_26 @[Q_table.scala 63:15]
    io.Q_prime_max <= max4.io.Q_max @[Q_table.scala 64:17]
    node _T_27 = bits(new_state_or_state, 4, 0) @[Q_table.scala 66:38]
    read mport _T_28 = Q_s_a0[_T_27], clock @[Q_table.scala 66:38]
    index_of_Q_max.io.ins0 <= _T_28 @[Q_table.scala 66:25]
    node _T_29 = bits(new_state_or_state, 4, 0) @[Q_table.scala 67:38]
    read mport _T_30 = Q_s_a0[_T_29], clock @[Q_table.scala 67:38]
    index_of_Q_max.io.ins1 <= _T_30 @[Q_table.scala 67:25]
    node _T_31 = bits(new_state_or_state, 4, 0) @[Q_table.scala 68:38]
    read mport _T_32 = Q_s_a0[_T_31], clock @[Q_table.scala 68:38]
    index_of_Q_max.io.ins2 <= _T_32 @[Q_table.scala 68:25]
    node _T_33 = bits(new_state_or_state, 4, 0) @[Q_table.scala 69:38]
    read mport _T_34 = Q_s_a0[_T_33], clock @[Q_table.scala 69:38]
    index_of_Q_max.io.ins3 <= _T_34 @[Q_table.scala 69:25]
    index_of_Q_max.io.Q_max_at_state_s <= max4.io.Q_max @[Q_table.scala 70:37]
    io.action_at_Qmax <= index_of_Q_max.io.action_at_Qmax @[Q_table.scala 71:20]
    
  module ConfirmReward : 
    input clock : Clock
    input reset : Reset
    output io : {flip new_state : UInt<6>, flip step : UInt<4>, reward : SInt<9>}
    
    node _T = eq(io.new_state, UInt<5>("h018")) @[Blocks.scala 68:20]
    when _T : @[Blocks.scala 68:28]
      io.reward <= asSInt(UInt<8>("h064")) @[Blocks.scala 68:38]
      skip @[Blocks.scala 68:28]
    else : @[Blocks.scala 69:192]
      node _T_1 = eq(io.new_state, UInt<3>("h04")) @[Blocks.scala 69:26]
      node _T_2 = eq(io.new_state, UInt<3>("h06")) @[Blocks.scala 69:48]
      node _T_3 = or(_T_1, _T_2) @[Blocks.scala 69:33]
      node _T_4 = eq(io.new_state, UInt<3>("h07")) @[Blocks.scala 69:69]
      node _T_5 = or(_T_3, _T_4) @[Blocks.scala 69:55]
      node _T_6 = eq(io.new_state, UInt<4>("h0d")) @[Blocks.scala 69:91]
      node _T_7 = or(_T_5, _T_6) @[Blocks.scala 69:76]
      node _T_8 = eq(io.new_state, UInt<5>("h010")) @[Blocks.scala 69:114]
      node _T_9 = or(_T_7, _T_8) @[Blocks.scala 69:99]
      node _T_10 = eq(io.new_state, UInt<5>("h012")) @[Blocks.scala 69:137]
      node _T_11 = or(_T_9, _T_10) @[Blocks.scala 69:122]
      node _T_12 = eq(io.new_state, UInt<5>("h013")) @[Blocks.scala 69:160]
      node _T_13 = or(_T_11, _T_12) @[Blocks.scala 69:145]
      node _T_14 = eq(io.new_state, UInt<5>("h015")) @[Blocks.scala 69:183]
      node _T_15 = or(_T_13, _T_14) @[Blocks.scala 69:168]
      when _T_15 : @[Blocks.scala 69:192]
        io.reward <= asSInt(UInt<9>("h0138")) @[Blocks.scala 69:203]
        skip @[Blocks.scala 69:192]
      else : @[Blocks.scala 70:29]
        node _T_16 = eq(io.step, UInt<4>("h0e")) @[Blocks.scala 70:21]
        when _T_16 : @[Blocks.scala 70:29]
          io.reward <= asSInt(UInt<7>("h04e")) @[Blocks.scala 71:14]
          skip @[Blocks.scala 70:29]
        else : @[Blocks.scala 72:14]
          io.reward <= asSInt(UInt<1>("h00")) @[Blocks.scala 73:14]
          skip @[Blocks.scala 72:14]
    
  module resetFMS : 
    input clock : Clock
    input reset : Reset
    output io : {flip transition : UInt<1>, reset : UInt<1>}
    
    reg active_reset_fms : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AgentsBrain.scala 9:31]
    io.reset <= UInt<1>("h00") @[AgentsBrain.scala 10:11]
    when io.transition : @[AgentsBrain.scala 11:22]
      active_reset_fms <= UInt<1>("h00") @[AgentsBrain.scala 12:21]
      skip @[AgentsBrain.scala 11:22]
    node _T = eq(UInt<1>("h00"), active_reset_fms) @[Conditional.scala 37:30]
    when _T : @[Conditional.scala 40:58]
      active_reset_fms <= UInt<1>("h01") @[AgentsBrain.scala 16:23]
      io.reset <= UInt<1>("h01") @[AgentsBrain.scala 17:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_1 = eq(UInt<1>("h01"), active_reset_fms) @[Conditional.scala 37:30]
      when _T_1 : @[Conditional.scala 39:67]
        skip @[Conditional.scala 39:67]
    
  module MasterFMS : 
    input clock : Clock
    input reset : Reset
    output io : {flip iterate : UInt<1>, flip move_to_confirming_Reward : UInt<1>, cal : UInt<1>, load_new_state : UInt<1>, reset_Action_fms : UInt<1>, get_Q_prime_max : UInt<1>, DONE : UInt<1>, flip path_found : UInt<1>}
    
    io.DONE <= UInt<1>("h00") @[AgentsBrain.scala 34:10]
    io.cal <= UInt<1>("h00") @[AgentsBrain.scala 35:9]
    io.get_Q_prime_max <= UInt<1>("h00") @[AgentsBrain.scala 36:21]
    io.load_new_state <= UInt<1>("h00") @[AgentsBrain.scala 37:20]
    reg master_FMS : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[AgentsBrain.scala 39:25]
    inst reset_fms of resetFMS @[AgentsBrain.scala 41:23]
    reset_fms.clock <= clock
    reset_fms.reset <= reset
    wire transition : UInt<1>
    transition <= UInt<1>("h00")
    reset_fms.io.transition <= transition @[AgentsBrain.scala 43:26]
    io.reset_Action_fms <= reset_fms.io.reset @[AgentsBrain.scala 44:22]
    io.reset_Action_fms <= UInt<1>("h00") @[AgentsBrain.scala 45:22]
    node _T = eq(UInt<3>("h00"), master_FMS) @[Conditional.scala 37:30]
    when _T : @[Conditional.scala 40:58]
      when io.iterate : @[AgentsBrain.scala 48:23]
        master_FMS <= UInt<3>("h00") @[AgentsBrain.scala 49:20]
        skip @[AgentsBrain.scala 48:23]
      else : @[AgentsBrain.scala 50:32]
        when io.path_found : @[AgentsBrain.scala 50:32]
          master_FMS <= UInt<3>("h04") @[AgentsBrain.scala 51:19]
          skip @[AgentsBrain.scala 50:32]
        else : @[AgentsBrain.scala 52:8]
          transition <= UInt<1>("h01") @[AgentsBrain.scala 53:21]
          master_FMS <= UInt<3>("h01") @[AgentsBrain.scala 54:21]
          skip @[AgentsBrain.scala 52:8]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_1 = eq(UInt<3>("h01"), master_FMS) @[Conditional.scala 37:30]
      when _T_1 : @[Conditional.scala 39:67]
        io.reset_Action_fms <= reset_fms.io.reset @[AgentsBrain.scala 58:26]
        when io.move_to_confirming_Reward : @[AgentsBrain.scala 59:42]
          master_FMS <= UInt<3>("h02") @[AgentsBrain.scala 60:20]
          skip @[AgentsBrain.scala 59:42]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_2 = eq(UInt<3>("h02"), master_FMS) @[Conditional.scala 37:30]
        when _T_2 : @[Conditional.scala 39:67]
          master_FMS <= UInt<3>("h03") @[AgentsBrain.scala 64:18]
          io.get_Q_prime_max <= UInt<1>("h01") @[AgentsBrain.scala 65:25]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<3>("h03"), master_FMS) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            io.cal <= UInt<1>("h01") @[AgentsBrain.scala 68:13]
            master_FMS <= UInt<3>("h00") @[AgentsBrain.scala 69:17]
            io.load_new_state <= UInt<1>("h01") @[AgentsBrain.scala 70:24]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<3>("h04"), master_FMS) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              io.DONE <= UInt<1>("h01") @[AgentsBrain.scala 73:12]
              skip @[Conditional.scala 39:67]
    
  module sloving_maze_by_RL : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip COL : UInt<3>, flip ROW : UInt<3>, flip state_read : UInt<6>, flip act_read : UInt<2>, Q_value : SInt<16>, flip write_data_into_a_txtfile : UInt<1>, DONE : UInt<1>}
    
    inst agent of Agent @[sloving_maze_by_RL.scala 13:19]
    agent.clock <= clock
    agent.reset <= reset
    inst taking_action of takingAction @[sloving_maze_by_RL.scala 14:27]
    taking_action.clock <= clock
    taking_action.reset <= reset
    inst Q_func of Q_function @[sloving_maze_by_RL.scala 15:20]
    Q_func.clock <= clock
    Q_func.reset <= reset
    inst Q_table of Qtable @[sloving_maze_by_RL.scala 16:21]
    Q_table.clock <= clock
    Q_table.reset <= reset
    inst Reward of ConfirmReward @[sloving_maze_by_RL.scala 17:20]
    Reward.clock <= clock
    Reward.reset <= reset
    inst masterFMS of MasterFMS @[sloving_maze_by_RL.scala 18:23]
    masterFMS.clock <= clock
    masterFMS.reset <= reset
    io.Q_value <= Q_table.io.Q_s_a @[sloving_maze_by_RL.scala 19:13]
    Q_table.io.state_read <= io.state_read @[sloving_maze_by_RL.scala 20:24]
    Q_table.io.act_read <= io.act_read @[sloving_maze_by_RL.scala 21:22]
    Q_table.io.write_data_into_a_txtfile <= io.write_data_into_a_txtfile @[sloving_maze_by_RL.scala 22:39]
    agent.io.ROW <= io.ROW @[sloving_maze_by_RL.scala 25:15]
    agent.io.COL <= io.COL @[sloving_maze_by_RL.scala 26:15]
    taking_action.io.x <= agent.io.x @[sloving_maze_by_RL.scala 29:13]
    taking_action.io.y <= agent.io.y @[sloving_maze_by_RL.scala 30:13]
    taking_action.io.episode <= agent.io.episode @[sloving_maze_by_RL.scala 31:19]
    agent.io.new_state <= taking_action.io.new_state @[sloving_maze_by_RL.scala 33:29]
    Q_table.io.new_state <= taking_action.io.new_state @[sloving_maze_by_RL.scala 34:29]
    Q_table.io.act <= taking_action.io.act @[sloving_maze_by_RL.scala 35:23]
    taking_action.io.action_at_Qmax <= Q_table.io.action_at_Qmax @[sloving_maze_by_RL.scala 36:34]
    Reward.io.new_state <= taking_action.io.new_state @[sloving_maze_by_RL.scala 38:22]
    Reward.io.step <= agent.io.step @[sloving_maze_by_RL.scala 39:17]
    Q_table.io.state <= agent.io.state @[sloving_maze_by_RL.scala 41:19]
    Q_func.io.Q_prime_max <= Q_table.io.Q_prime_max @[sloving_maze_by_RL.scala 42:24]
    Q_func.io.Q_s_a <= Q_table.io.Q_s_a @[sloving_maze_by_RL.scala 43:18]
    Q_func.io.reward <= Reward.io.reward @[sloving_maze_by_RL.scala 44:19]
    Q_func.io.cal <= masterFMS.io.cal @[sloving_maze_by_RL.scala 45:16]
    Q_table.io.wrEna <= Q_func.io.wrEna @[sloving_maze_by_RL.scala 46:18]
    Q_table.io.Q_updated <= Q_func.io.Q_updated @[sloving_maze_by_RL.scala 47:22]
    taking_action.io.reset_Action_fms <= masterFMS.io.reset_Action_fms @[sloving_maze_by_RL.scala 50:32]
    masterFMS.io.iterate <= agent.io.iterate @[sloving_maze_by_RL.scala 52:23]
    masterFMS.io.move_to_confirming_Reward <= taking_action.io.move_to_confirming_Reward @[sloving_maze_by_RL.scala 53:41]
    Q_table.io.get_Q_prime_max <= masterFMS.io.get_Q_prime_max @[sloving_maze_by_RL.scala 54:31]
    agent.io.load_new_state <= masterFMS.io.load_new_state @[sloving_maze_by_RL.scala 55:26]
    taking_action.io.get_path <= agent.io.done_learning @[sloving_maze_by_RL.scala 56:25]
    masterFMS.io.path_found <= agent.io.path_found @[sloving_maze_by_RL.scala 57:26]
    io.DONE <= masterFMS.io.DONE @[sloving_maze_by_RL.scala 58:20]
    
