;buildInfoPackage: chisel3, version: 3.2.2, scalaVersion: 2.11.12, sbtVersion: 1.3.2
circuit sloving_maze_by_RL : 
  module Agent : 
    input clock : Clock
    input reset : Reset
    output io : {flip ROW : UInt<3>, flip COL : UInt<3>, flip new_state : UInt<6>, iterate : UInt<1>, x : UInt<3>, y : UInt<3>, state : UInt<6>, episode : UInt<9>, done_learning : UInt<1>, flip load_new_state : UInt<1>, step : UInt<4>, t : UInt<1>}
    
    reg ROW : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Blocks.scala 18:18]
    reg COL : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Blocks.scala 19:18]
    reg state : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[Blocks.scala 20:20]
    reg episode : UInt<9>, clock with : (reset => (reset, UInt<9>("h00"))) @[Blocks.scala 21:22]
    ROW <= io.ROW @[Blocks.scala 24:6]
    COL <= io.COL @[Blocks.scala 25:6]
    node start_again = eq(io.new_state, UInt<5>("h018")) @[Blocks.scala 26:31]
    reg step : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Blocks.scala 27:21]
    node t = eq(step, UInt<4>("h0f")) @[Blocks.scala 28:14]
    node iterate = or(start_again, t) @[Blocks.scala 29:26]
    io.iterate <= iterate @[Blocks.scala 30:13]
    io.t <= t @[Blocks.scala 31:7]
    node _T = eq(iterate, UInt<1>("h01")) @[Blocks.scala 32:15]
    when _T : @[Blocks.scala 32:25]
      state <= UInt<1>("h00") @[Blocks.scala 33:10]
      node _T_1 = add(episode, UInt<1>("h01")) @[Blocks.scala 34:21]
      node _T_2 = tail(_T_1, 1) @[Blocks.scala 34:21]
      episode <= _T_2 @[Blocks.scala 34:12]
      skip @[Blocks.scala 32:25]
    else : @[Blocks.scala 35:4]
      when io.load_new_state : @[Blocks.scala 36:29]
        state <= io.new_state @[Blocks.scala 37:13]
        io.done_learning <= UInt<1>("h00") @[Blocks.scala 38:24]
        node _T_3 = add(step, UInt<1>("h01")) @[Blocks.scala 39:17]
        node _T_4 = tail(_T_3, 1) @[Blocks.scala 39:17]
        step <= _T_4 @[Blocks.scala 39:11]
        skip @[Blocks.scala 36:29]
      skip @[Blocks.scala 35:4]
    node _T_5 = eq(episode, UInt<9>("h012c")) @[Blocks.scala 43:15]
    when _T_5 : @[Blocks.scala 43:24]
      io.done_learning <= UInt<1>("h01") @[Blocks.scala 44:21]
      skip @[Blocks.scala 43:24]
    else : @[Blocks.scala 45:4]
      io.done_learning <= UInt<1>("h00") @[Blocks.scala 46:21]
      skip @[Blocks.scala 45:4]
    node _T_6 = rem(state, COL) @[Blocks.scala 49:14]
    io.x <= _T_6 @[Blocks.scala 49:7]
    node _T_7 = div(state, COL) @[Blocks.scala 50:14]
    io.y <= _T_7 @[Blocks.scala 50:7]
    io.state <= state @[Blocks.scala 51:11]
    io.episode <= episode @[Blocks.scala 52:13]
    io.step <= step @[Blocks.scala 53:10]
    
  module Action_FMS : 
    input clock : Clock
    input reset : Reset
    output io : {flip reset_Action : UInt<1>, flip exploit : UInt<1>, flip validAction : UInt<1>, move_to_confirming_Reward : UInt<1>}
    
    reg action_FMS : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Action and ActionFMS.scala 12:25]
    io.move_to_confirming_Reward <= UInt<1>("h00") @[Action and ActionFMS.scala 13:31]
    when io.reset_Action : @[Action and ActionFMS.scala 14:24]
      action_FMS <= UInt<3>("h00") @[Action and ActionFMS.scala 15:15]
      skip @[Action and ActionFMS.scala 14:24]
    node _T = eq(UInt<3>("h00"), action_FMS) @[Conditional.scala 37:30]
    when _T : @[Conditional.scala 40:58]
      when io.exploit : @[Action and ActionFMS.scala 19:23]
        action_FMS <= UInt<3>("h01") @[Action and ActionFMS.scala 20:19]
        skip @[Action and ActionFMS.scala 19:23]
      else : @[Action and ActionFMS.scala 21:8]
        action_FMS <= UInt<3>("h02") @[Action and ActionFMS.scala 22:19]
        skip @[Action and ActionFMS.scala 21:8]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_1 = eq(UInt<3>("h01"), action_FMS) @[Conditional.scala 37:30]
      when _T_1 : @[Conditional.scala 39:67]
        action_FMS <= UInt<3>("h03") @[Action and ActionFMS.scala 26:17]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_2 = eq(UInt<3>("h02"), action_FMS) @[Conditional.scala 37:30]
        when _T_2 : @[Conditional.scala 39:67]
          action_FMS <= UInt<3>("h03") @[Action and ActionFMS.scala 29:17]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<3>("h03"), action_FMS) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            action_FMS <= UInt<3>("h04") @[Action and ActionFMS.scala 32:17]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<3>("h04"), action_FMS) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.validAction : @[Action and ActionFMS.scala 35:27]
                io.move_to_confirming_Reward <= UInt<1>("h01") @[Action and ActionFMS.scala 36:37]
                skip @[Action and ActionFMS.scala 35:27]
              else : @[Action and ActionFMS.scala 37:18]
                action_FMS <= UInt<3>("h00") @[Action and ActionFMS.scala 38:19]
                skip @[Action and ActionFMS.scala 37:18]
              skip @[Conditional.scala 39:67]
    
  module Action : 
    input clock : Clock
    input reset : Reset
    output io : {flip x : UInt<3>, flip y : UInt<3>, flip rand2 : UInt<10>, new_state : UInt<6>, act : UInt<2>, flip action_at_Qmax : UInt<2>, flip exploit : UInt<1>, validAction : UInt<1>}
    
    reg act : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Action and ActionFMS.scala 54:20]
    reg x_new : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Action and ActionFMS.scala 55:22]
    reg y_new : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[Action and ActionFMS.scala 56:22]
    reg new_state : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[Action and ActionFMS.scala 57:24]
    reg action_at_Qmax : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Action and ActionFMS.scala 58:29]
    action_at_Qmax <= io.action_at_Qmax @[Action and ActionFMS.scala 60:17]
    when io.exploit : @[Action and ActionFMS.scala 61:19]
      act <= action_at_Qmax @[Action and ActionFMS.scala 62:8]
      skip @[Action and ActionFMS.scala 61:19]
    else : @[Action and ActionFMS.scala 63:4]
      node _T = leq(io.rand2, UInt<8>("h0fa")) @[Action and ActionFMS.scala 64:19]
      when _T : @[Action and ActionFMS.scala 64:29]
        act <= UInt<1>("h00") @[Action and ActionFMS.scala 65:11]
        skip @[Action and ActionFMS.scala 64:29]
      else : @[Action and ActionFMS.scala 66:70]
        node _T_1 = lt(UInt<8>("h0fa"), io.rand2) @[Action and ActionFMS.scala 66:23]
        node _T_2 = leq(io.rand2, UInt<9>("h01f4")) @[Action and ActionFMS.scala 66:48]
        node _T_3 = eq(_T_2, UInt<1>("h01")) @[Action and ActionFMS.scala 66:58]
        node _T_4 = and(_T_1, _T_3) @[Action and ActionFMS.scala 66:35]
        when _T_4 : @[Action and ActionFMS.scala 66:70]
          act <= UInt<1>("h01") @[Action and ActionFMS.scala 67:11]
          skip @[Action and ActionFMS.scala 66:70]
        else : @[Action and ActionFMS.scala 68:70]
          node _T_5 = lt(UInt<9>("h01f4"), io.rand2) @[Action and ActionFMS.scala 68:23]
          node _T_6 = leq(io.rand2, UInt<10>("h02ee")) @[Action and ActionFMS.scala 68:48]
          node _T_7 = eq(_T_6, UInt<1>("h01")) @[Action and ActionFMS.scala 68:58]
          node _T_8 = and(_T_5, _T_7) @[Action and ActionFMS.scala 68:35]
          when _T_8 : @[Action and ActionFMS.scala 68:70]
            act <= UInt<2>("h02") @[Action and ActionFMS.scala 69:11]
            skip @[Action and ActionFMS.scala 68:70]
          else : @[Action and ActionFMS.scala 70:7]
            act <= UInt<2>("h03") @[Action and ActionFMS.scala 71:11]
            skip @[Action and ActionFMS.scala 70:7]
      skip @[Action and ActionFMS.scala 63:4]
    node _T_9 = eq(act, UInt<1>("h00")) @[Action and ActionFMS.scala 74:12]
    when _T_9 : @[Action and ActionFMS.scala 74:21]
      node _T_10 = add(io.y, UInt<1>("h01")) @[Action and ActionFMS.scala 75:19]
      node _T_11 = tail(_T_10, 1) @[Action and ActionFMS.scala 75:19]
      y_new <= _T_11 @[Action and ActionFMS.scala 75:11]
      x_new <= io.x @[Action and ActionFMS.scala 76:11]
      skip @[Action and ActionFMS.scala 74:21]
    else : @[Action and ActionFMS.scala 77:27]
      node _T_12 = eq(act, UInt<1>("h01")) @[Action and ActionFMS.scala 77:18]
      when _T_12 : @[Action and ActionFMS.scala 77:27]
        node _T_13 = sub(io.x, UInt<1>("h01")) @[Action and ActionFMS.scala 78:19]
        node _T_14 = tail(_T_13, 1) @[Action and ActionFMS.scala 78:19]
        x_new <= _T_14 @[Action and ActionFMS.scala 78:11]
        y_new <= io.y @[Action and ActionFMS.scala 79:11]
        skip @[Action and ActionFMS.scala 77:27]
      else : @[Action and ActionFMS.scala 80:27]
        node _T_15 = eq(act, UInt<2>("h02")) @[Action and ActionFMS.scala 80:18]
        when _T_15 : @[Action and ActionFMS.scala 80:27]
          node _T_16 = sub(io.y, UInt<1>("h01")) @[Action and ActionFMS.scala 81:19]
          node _T_17 = tail(_T_16, 1) @[Action and ActionFMS.scala 81:19]
          y_new <= _T_17 @[Action and ActionFMS.scala 81:11]
          x_new <= io.x @[Action and ActionFMS.scala 82:11]
          skip @[Action and ActionFMS.scala 80:27]
        else : @[Action and ActionFMS.scala 83:5]
          node _T_18 = add(io.x, UInt<1>("h01")) @[Action and ActionFMS.scala 84:19]
          node _T_19 = tail(_T_18, 1) @[Action and ActionFMS.scala 84:19]
          x_new <= _T_19 @[Action and ActionFMS.scala 84:11]
          y_new <= io.y @[Action and ActionFMS.scala 85:11]
          skip @[Action and ActionFMS.scala 83:5]
    node _T_20 = eq(x_new, UInt<3>("h07")) @[Action and ActionFMS.scala 87:14]
    node _T_21 = eq(x_new, UInt<3>("h05")) @[Action and ActionFMS.scala 87:31]
    node _T_22 = or(_T_20, _T_21) @[Action and ActionFMS.scala 87:22]
    node _T_23 = eq(y_new, UInt<3>("h07")) @[Action and ActionFMS.scala 87:48]
    node _T_24 = or(_T_22, _T_23) @[Action and ActionFMS.scala 87:39]
    node _T_25 = eq(y_new, UInt<3>("h05")) @[Action and ActionFMS.scala 87:65]
    node _T_26 = or(_T_24, _T_25) @[Action and ActionFMS.scala 87:56]
    when _T_26 : @[Action and ActionFMS.scala 87:73]
      io.validAction <= UInt<1>("h00") @[Action and ActionFMS.scala 88:19]
      skip @[Action and ActionFMS.scala 87:73]
    else : @[Action and ActionFMS.scala 89:4]
      node _T_27 = mul(UInt<3>("h05"), y_new) @[Action and ActionFMS.scala 90:25]
      node _T_28 = add(x_new, _T_27) @[Action and ActionFMS.scala 90:21]
      node _T_29 = tail(_T_28, 1) @[Action and ActionFMS.scala 90:21]
      new_state <= _T_29 @[Action and ActionFMS.scala 90:14]
      io.validAction <= UInt<1>("h01") @[Action and ActionFMS.scala 91:19]
      skip @[Action and ActionFMS.scala 89:4]
    io.act <= act @[Action and ActionFMS.scala 93:9]
    io.new_state <= new_state @[Action and ActionFMS.scala 94:15]
    
  module takingAction : 
    input clock : Clock
    input reset : Reset
    output io : {flip x : UInt<3>, flip y : UInt<3>, flip rand1 : UInt<10>, flip rand2 : UInt<10>, flip episode : UInt<9>, new_state : UInt<6>, flip action_at_Qmax : UInt<2>, act : UInt<2>, flip reset_Action : UInt<1>, move_to_confirming_Reward : UInt<1>}
    
    inst action_fms of Action_FMS @[taking_Action.scala 16:24]
    action_fms.clock <= clock
    action_fms.reset <= reset
    inst action of Action @[taking_Action.scala 17:20]
    action.clock <= clock
    action.reset <= reset
    reg epsilon : UInt<10>, clock with : (reset => (reset, UInt<10>("h00"))) @[taking_Action.scala 18:24]
    node _T = mul(io.episode, UInt<4>("h0a")) @[taking_Action.scala 19:34]
    node _T_1 = div(_T, UInt<2>("h03")) @[taking_Action.scala 19:41]
    node _T_2 = sub(UInt<10>("h03e8"), _T_1) @[taking_Action.scala 19:21]
    node _T_3 = tail(_T_2, 1) @[taking_Action.scala 19:21]
    epsilon <= _T_3 @[taking_Action.scala 19:11]
    node exploit = leq(epsilon, io.rand1) @[taking_Action.scala 20:23]
    action_fms.io.reset_Action <= io.reset_Action @[taking_Action.scala 22:29]
    action_fms.io.exploit <= exploit @[taking_Action.scala 23:24]
    action_fms.io.validAction <= action.io.validAction @[taking_Action.scala 24:28]
    action.io.exploit <= exploit @[taking_Action.scala 27:20]
    action.io.rand2 <= io.rand2 @[taking_Action.scala 28:18]
    action.io.x <= io.x @[taking_Action.scala 29:14]
    action.io.y <= io.y @[taking_Action.scala 30:14]
    action.io.action_at_Qmax <= io.action_at_Qmax @[taking_Action.scala 31:27]
    io.act <= action.io.act @[taking_Action.scala 33:9]
    io.new_state <= action.io.new_state @[taking_Action.scala 34:15]
    io.move_to_confirming_Reward <= action_fms.io.move_to_confirming_Reward @[taking_Action.scala 35:31]
    
  module Q_function : 
    input clock : Clock
    input reset : Reset
    output io : {flip Q_s_a : SInt<21>, flip Q_prime_max : SInt<21>, Q_updated : SInt<21>, flip cal : UInt<1>, flip reward : SInt<8>, wrEna : UInt<1>}
    
    reg Q_s_a : SInt<21>, clock with : (reset => (reset, asSInt(UInt<21>("h00")))) @[Q_function.scala 12:20]
    reg Q_prime_max : SInt<21>, clock with : (reset => (reset, asSInt(UInt<21>("h00")))) @[Q_function.scala 13:26]
    reg reward : SInt<8>, clock with : (reset => (reset, asSInt(UInt<8>("h00")))) @[Q_function.scala 14:21]
    Q_s_a <= io.Q_s_a @[Q_function.scala 15:8]
    Q_prime_max <= io.Q_prime_max @[Q_function.scala 16:14]
    reward <= io.reward @[Q_function.scala 17:9]
    when io.cal : @[Q_function.scala 18:15]
      node _T = div(Q_s_a, asSInt(UInt<3>("h02"))) @[Q_function.scala 19:25]
      node _T_1 = mul(asSInt(UInt<5>("h09")), Q_prime_max) @[Q_function.scala 19:47]
      node _T_2 = div(_T_1, asSInt(UInt<5>("h0a"))) @[Q_function.scala 19:60]
      node _T_3 = add(reward, _T_2) @[Q_function.scala 19:42]
      node _T_4 = tail(_T_3, 1) @[Q_function.scala 19:42]
      node _T_5 = asSInt(_T_4) @[Q_function.scala 19:42]
      node _T_6 = div(_T_5, asSInt(UInt<3>("h02"))) @[Q_function.scala 19:68]
      node _T_7 = add(_T, _T_6) @[Q_function.scala 19:32]
      node _T_8 = tail(_T_7, 1) @[Q_function.scala 19:32]
      node _T_9 = asSInt(_T_8) @[Q_function.scala 19:32]
      io.Q_updated <= _T_9 @[Q_function.scala 19:18]
      io.wrEna <= UInt<1>("h01") @[Q_function.scala 20:13]
      skip @[Q_function.scala 18:15]
    else : @[Q_function.scala 21:4]
      io.Q_updated <= asSInt(UInt<1>("h00")) @[Q_function.scala 22:17]
      io.wrEna <= UInt<1>("h00") @[Q_function.scala 23:13]
      skip @[Q_function.scala 21:4]
    
  module Qtable : 
    input clock : Clock
    input reset : Reset
    output io : {flip state : UInt<7>, flip new_state : UInt<7>, flip act : UInt<2>, flip wrEna : UInt<1>, flip Q_updated : SInt<21>, Q_s_a : SInt<21>, Q_prime_max : SInt<21>, action_at_Qmax : UInt<2>}
    
    smem Q_s_Act0 : SInt<21>[25] @[Q_table.scala 15:27]
    smem Q_s_Act1 : SInt<21>[25] @[Q_table.scala 16:27]
    smem Q_s_Act2 : SInt<21>[25] @[Q_table.scala 17:27]
    smem Q_s_Act3 : SInt<21>[25] @[Q_table.scala 18:27]
    wire ins : SInt<21>[4] @[Q_table.scala 20:15]
    reg state : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[Q_table.scala 21:20]
    state <= io.state @[Q_table.scala 22:8]
    node _T = bits(io.new_state, 4, 0) @[Q_table.scala 23:24]
    read mport _T_1 = Q_s_Act0[_T], clock @[Q_table.scala 23:24]
    ins[0] <= _T_1 @[Q_table.scala 23:9]
    node _T_2 = bits(io.new_state, 4, 0) @[Q_table.scala 24:24]
    read mport _T_3 = Q_s_Act1[_T_2], clock @[Q_table.scala 24:24]
    ins[1] <= _T_3 @[Q_table.scala 24:9]
    node _T_4 = bits(io.new_state, 4, 0) @[Q_table.scala 25:24]
    read mport _T_5 = Q_s_Act2[_T_4], clock @[Q_table.scala 25:24]
    ins[2] <= _T_5 @[Q_table.scala 25:9]
    node _T_6 = bits(io.new_state, 4, 0) @[Q_table.scala 26:24]
    read mport _T_7 = Q_s_Act3[_T_6], clock @[Q_table.scala 26:24]
    ins[3] <= _T_7 @[Q_table.scala 26:9]
    node _T_8 = gt(ins[0], ins[1]) @[Q_table.scala 27:46]
    node _T_9 = mux(_T_8, ins[0], ins[1]) @[Q_table.scala 27:43]
    node _T_10 = gt(_T_9, ins[2]) @[Q_table.scala 27:46]
    node _T_11 = mux(_T_10, _T_9, ins[2]) @[Q_table.scala 27:43]
    node _T_12 = gt(_T_11, ins[3]) @[Q_table.scala 27:46]
    node _T_13 = mux(_T_12, _T_11, ins[3]) @[Q_table.scala 27:43]
    io.Q_prime_max <= _T_13 @[Q_table.scala 28:17]
    node _T_14 = eq(io.state, UInt<1>("h00")) @[Q_table.scala 30:16]
    when _T_14 : @[Q_table.scala 30:23]
      node _T_15 = bits(io.state, 4, 0) @[Q_table.scala 31:28]
      read mport _T_16 = Q_s_Act0[_T_15], clock @[Q_table.scala 31:28]
      io.Q_s_a <= _T_16 @[Q_table.scala 31:13]
      when io.wrEna : @[Q_table.scala 32:20]
        node _T_17 = bits(io.state, 4, 0) @[Q_table.scala 33:30]
        read mport _T_18 = Q_s_Act0[_T_17], clock @[Q_table.scala 33:30]
        io.Q_s_a <= _T_18 @[Q_table.scala 33:15]
        node _T_19 = bits(state, 4, 0)
        write mport _T_20 = Q_s_Act0[_T_19], clock
        _T_20 <= io.Q_updated
        skip @[Q_table.scala 32:20]
      skip @[Q_table.scala 30:23]
    else : @[Q_table.scala 36:29]
      node _T_21 = eq(io.state, UInt<1>("h01")) @[Q_table.scala 36:22]
      when _T_21 : @[Q_table.scala 36:29]
        node _T_22 = bits(io.state, 4, 0) @[Q_table.scala 37:28]
        read mport _T_23 = Q_s_Act1[_T_22], clock @[Q_table.scala 37:28]
        io.Q_s_a <= _T_23 @[Q_table.scala 37:13]
        when io.wrEna : @[Q_table.scala 38:20]
          node _T_24 = bits(state, 4, 0)
          write mport _T_25 = Q_s_Act1[_T_24], clock
          _T_25 <= io.Q_updated
          skip @[Q_table.scala 38:20]
        skip @[Q_table.scala 36:29]
      else : @[Q_table.scala 41:29]
        node _T_26 = eq(io.state, UInt<2>("h02")) @[Q_table.scala 41:22]
        when _T_26 : @[Q_table.scala 41:29]
          node _T_27 = bits(io.state, 4, 0) @[Q_table.scala 42:28]
          read mport _T_28 = Q_s_Act2[_T_27], clock @[Q_table.scala 42:28]
          io.Q_s_a <= _T_28 @[Q_table.scala 42:13]
          when io.wrEna : @[Q_table.scala 43:20]
            node _T_29 = bits(state, 4, 0)
            write mport _T_30 = Q_s_Act2[_T_29], clock
            _T_30 <= io.Q_updated
            skip @[Q_table.scala 43:20]
          skip @[Q_table.scala 41:29]
        else : @[Q_table.scala 46:4]
          node _T_31 = bits(io.state, 4, 0) @[Q_table.scala 47:28]
          read mport _T_32 = Q_s_Act3[_T_31], clock @[Q_table.scala 47:28]
          io.Q_s_a <= _T_32 @[Q_table.scala 47:13]
          when io.wrEna : @[Q_table.scala 48:19]
            node _T_33 = bits(state, 4, 0)
            write mport _T_34 = Q_s_Act0[_T_33], clock
            _T_34 <= io.Q_updated
            skip @[Q_table.scala 48:19]
          skip @[Q_table.scala 46:4]
    wire ins1 : SInt<21>[4] @[Q_table.scala 53:16]
    node _T_35 = bits(io.state, 4, 0) @[Q_table.scala 54:25]
    read mport _T_36 = Q_s_Act0[_T_35], clock @[Q_table.scala 54:25]
    ins1[0] <= _T_36 @[Q_table.scala 54:10]
    node _T_37 = bits(io.state, 4, 0) @[Q_table.scala 55:25]
    read mport _T_38 = Q_s_Act1[_T_37], clock @[Q_table.scala 55:25]
    ins1[1] <= _T_38 @[Q_table.scala 55:10]
    node _T_39 = bits(io.state, 4, 0) @[Q_table.scala 56:25]
    read mport _T_40 = Q_s_Act2[_T_39], clock @[Q_table.scala 56:25]
    ins1[2] <= _T_40 @[Q_table.scala 56:10]
    node _T_41 = bits(io.state, 4, 0) @[Q_table.scala 57:25]
    read mport _T_42 = Q_s_Act3[_T_41], clock @[Q_table.scala 57:25]
    ins1[3] <= _T_42 @[Q_table.scala 57:10]
    node _T_43 = eq(ins1[0], io.Q_s_a) @[Q_table.scala 58:43]
    node _T_44 = eq(ins1[1], io.Q_s_a) @[Q_table.scala 58:43]
    node _T_45 = eq(ins1[2], io.Q_s_a) @[Q_table.scala 58:43]
    node _T_46 = eq(ins1[3], io.Q_s_a) @[Q_table.scala 58:43]
    node _T_47 = mux(_T_45, UInt<2>("h02"), UInt<2>("h03")) @[Q_table.scala 58:37]
    node _T_48 = mux(_T_44, UInt<1>("h01"), _T_47) @[Q_table.scala 58:37]
    node _T_49 = mux(_T_43, UInt<1>("h00"), _T_48) @[Q_table.scala 58:37]
    io.action_at_Qmax <= _T_49 @[Q_table.scala 58:20]
    
  module ConfirmReward : 
    input clock : Clock
    input reset : Reset
    output io : {flip new_state : UInt<6>, flip step : UInt<4>, reward : SInt<8>}
    
    node _T = eq(io.new_state, UInt<5>("h018")) @[Blocks.scala 76:20]
    when _T : @[Blocks.scala 76:28]
      io.reward <= asSInt(UInt<8>("h064")) @[Blocks.scala 76:38]
      skip @[Blocks.scala 76:28]
    else : @[Blocks.scala 77:29]
      node _T_1 = eq(io.step, UInt<4>("h0f")) @[Blocks.scala 77:21]
      when _T_1 : @[Blocks.scala 77:29]
        io.reward <= asSInt(UInt<7>("h04e")) @[Blocks.scala 78:14]
        skip @[Blocks.scala 77:29]
      else : @[Blocks.scala 79:192]
        node _T_2 = eq(io.new_state, UInt<3>("h04")) @[Blocks.scala 79:26]
        node _T_3 = eq(io.new_state, UInt<3>("h06")) @[Blocks.scala 79:48]
        node _T_4 = or(_T_2, _T_3) @[Blocks.scala 79:33]
        node _T_5 = eq(io.new_state, UInt<3>("h07")) @[Blocks.scala 79:69]
        node _T_6 = or(_T_4, _T_5) @[Blocks.scala 79:55]
        node _T_7 = eq(io.new_state, UInt<4>("h0d")) @[Blocks.scala 79:91]
        node _T_8 = or(_T_6, _T_7) @[Blocks.scala 79:76]
        node _T_9 = eq(io.new_state, UInt<5>("h010")) @[Blocks.scala 79:114]
        node _T_10 = or(_T_8, _T_9) @[Blocks.scala 79:99]
        node _T_11 = eq(io.new_state, UInt<5>("h012")) @[Blocks.scala 79:137]
        node _T_12 = or(_T_10, _T_11) @[Blocks.scala 79:122]
        node _T_13 = eq(io.new_state, UInt<5>("h013")) @[Blocks.scala 79:160]
        node _T_14 = or(_T_12, _T_13) @[Blocks.scala 79:145]
        node _T_15 = eq(io.new_state, UInt<5>("h015")) @[Blocks.scala 79:183]
        node _T_16 = or(_T_14, _T_15) @[Blocks.scala 79:168]
        when _T_16 : @[Blocks.scala 79:192]
          io.reward <= asSInt(UInt<8>("h09c")) @[Blocks.scala 79:203]
          skip @[Blocks.scala 79:192]
        else : @[Blocks.scala 80:14]
          io.reward <= asSInt(UInt<1>("h00")) @[Blocks.scala 81:14]
          skip @[Blocks.scala 80:14]
    
  module AgentsBrain : 
    input clock : Clock
    input reset : Reset
    output io : {flip iterate : UInt<1>, flip done_learning : UInt<1>, flip move_to_confirming_Reward : UInt<1>, Path_found : UInt<1>, cal : UInt<1>, load_new_state : UInt<1>, reset_Action : UInt<1>}
    
    reg state_Reg : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[AgentsBrain.scala 16:24]
    io.load_new_state <= UInt<1>("h00") @[AgentsBrain.scala 17:20]
    io.reset_Action <= UInt<1>("h00") @[AgentsBrain.scala 19:18]
    io.Path_found <= UInt<1>("h00") @[AgentsBrain.scala 20:17]
    io.cal <= UInt<1>("h00") @[AgentsBrain.scala 21:9]
    node _T = eq(UInt<3>("h00"), state_Reg) @[Conditional.scala 37:30]
    when _T : @[Conditional.scala 40:58]
      when io.iterate : @[AgentsBrain.scala 24:23]
        state_Reg <= UInt<3>("h00") @[AgentsBrain.scala 25:19]
        skip @[AgentsBrain.scala 24:23]
      else : @[AgentsBrain.scala 26:35]
        when io.done_learning : @[AgentsBrain.scala 26:35]
          state_Reg <= UInt<3>("h04") @[AgentsBrain.scala 27:19]
          skip @[AgentsBrain.scala 26:35]
        else : @[AgentsBrain.scala 28:8]
          state_Reg <= UInt<3>("h01") @[AgentsBrain.scala 29:19]
          io.reset_Action <= UInt<1>("h01") @[AgentsBrain.scala 30:24]
          skip @[AgentsBrain.scala 28:8]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_1 = eq(UInt<3>("h01"), state_Reg) @[Conditional.scala 37:30]
      when _T_1 : @[Conditional.scala 39:67]
        when io.move_to_confirming_Reward : @[AgentsBrain.scala 34:42]
          state_Reg <= UInt<3>("h02") @[AgentsBrain.scala 35:19]
          skip @[AgentsBrain.scala 34:42]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_2 = eq(UInt<3>("h02"), state_Reg) @[Conditional.scala 37:30]
        when _T_2 : @[Conditional.scala 39:67]
          state_Reg <= UInt<3>("h03") @[AgentsBrain.scala 39:17]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<3>("h03"), state_Reg) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            io.cal <= UInt<1>("h01") @[AgentsBrain.scala 43:13]
            state_Reg <= UInt<3>("h00") @[AgentsBrain.scala 44:16]
            io.load_new_state <= UInt<1>("h01") @[AgentsBrain.scala 45:24]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<3>("h04"), state_Reg) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              io.Path_found <= UInt<1>("h01") @[AgentsBrain.scala 48:20]
              skip @[Conditional.scala 39:67]
    
  module sloving_maze_by_RL : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip rand1 : UInt<10>, flip rand2 : UInt<10>, Path_found : UInt<1>, flip COL : UInt<3>, flip ROW : UInt<3>}
    
    inst agent of Agent @[sloving_maze_by_RL.scala 14:19]
    agent.clock <= clock
    agent.reset <= reset
    inst taking_action of takingAction @[sloving_maze_by_RL.scala 15:27]
    taking_action.clock <= clock
    taking_action.reset <= reset
    inst Q_func of Q_function @[sloving_maze_by_RL.scala 16:20]
    Q_func.clock <= clock
    Q_func.reset <= reset
    inst Q_table of Qtable @[sloving_maze_by_RL.scala 17:21]
    Q_table.clock <= clock
    Q_table.reset <= reset
    inst Reward of ConfirmReward @[sloving_maze_by_RL.scala 18:20]
    Reward.clock <= clock
    Reward.reset <= reset
    inst brain_of_the_Agent of AgentsBrain @[sloving_maze_by_RL.scala 19:32]
    brain_of_the_Agent.clock <= clock
    brain_of_the_Agent.reset <= reset
    agent.io.ROW <= io.ROW @[sloving_maze_by_RL.scala 22:15]
    agent.io.COL <= io.COL @[sloving_maze_by_RL.scala 23:15]
    taking_action.io.rand1 <= io.rand1 @[sloving_maze_by_RL.scala 24:11]
    taking_action.io.rand2 <= io.rand2 @[sloving_maze_by_RL.scala 25:11]
    taking_action.io.x <= agent.io.x @[sloving_maze_by_RL.scala 26:13]
    taking_action.io.y <= agent.io.y @[sloving_maze_by_RL.scala 27:13]
    taking_action.io.episode <= agent.io.episode @[sloving_maze_by_RL.scala 28:19]
    agent.io.new_state <= taking_action.io.new_state @[sloving_maze_by_RL.scala 30:29]
    Q_table.io.new_state <= taking_action.io.new_state @[sloving_maze_by_RL.scala 31:29]
    Q_table.io.act <= taking_action.io.act @[sloving_maze_by_RL.scala 32:23]
    taking_action.io.action_at_Qmax <= Q_table.io.action_at_Qmax @[sloving_maze_by_RL.scala 33:34]
    Reward.io.new_state <= taking_action.io.new_state @[sloving_maze_by_RL.scala 35:22]
    Reward.io.step <= agent.io.step @[sloving_maze_by_RL.scala 36:17]
    Q_table.io.state <= agent.io.state @[sloving_maze_by_RL.scala 38:19]
    Q_func.io.Q_prime_max <= Q_table.io.Q_prime_max @[sloving_maze_by_RL.scala 39:24]
    Q_func.io.Q_s_a <= Q_table.io.Q_s_a @[sloving_maze_by_RL.scala 40:18]
    Q_func.io.reward <= Reward.io.reward @[sloving_maze_by_RL.scala 41:19]
    Q_func.io.cal <= brain_of_the_Agent.io.cal @[sloving_maze_by_RL.scala 42:16]
    Q_table.io.wrEna <= Q_func.io.wrEna @[sloving_maze_by_RL.scala 43:18]
    Q_table.io.Q_updated <= Q_func.io.Q_updated @[sloving_maze_by_RL.scala 44:22]
    taking_action.io.reset_Action <= brain_of_the_Agent.io.reset_Action @[sloving_maze_by_RL.scala 47:37]
    brain_of_the_Agent.io.done_learning <= agent.io.done_learning @[sloving_maze_by_RL.scala 48:38]
    brain_of_the_Agent.io.iterate <= agent.io.iterate @[sloving_maze_by_RL.scala 49:32]
    brain_of_the_Agent.io.move_to_confirming_Reward <= taking_action.io.move_to_confirming_Reward @[sloving_maze_by_RL.scala 50:50]
    agent.io.load_new_state <= brain_of_the_Agent.io.load_new_state @[sloving_maze_by_RL.scala 51:26]
    io.Path_found <= brain_of_the_Agent.io.Path_found @[sloving_maze_by_RL.scala 52:16]
    
